# [Item64] 객체는 인터페이스를 사용해 참조하라

## 아이템 51의 매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라와 비슷한 내용이다.

위의 내용을 확장하여 객체는 클래스가 아닌 인터페이스로 참조하라는 말이다.

적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.

실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 때 뿐이다.

인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.

구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자 또는 다른 정적 팩터리를 호출해주기만 하면 된다.

주변 코드는 옛 클래스의 존재를 애초부터 몰랐으니 이러한 변화에 아무런 영향도 받지 않는다.

## 주의점

원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변의 코드가 이 기능에 의존하여 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다!

이 책에서 제시하는 예시는 다음과 같다.

- 기존의 코드가 `LinkedHashSet` 의 순서 정책을 가정하고 동작하는 코드이다.
- 이를 HashSet으로 변경하면 문제가 된다.
- `HashSet`은 순서를 보장하지 않기 때문이다.

적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.

1. String 과 BigInteger 같은 값 클래스가 그러한데, 값 클래스를 여러 가지로 구현될 수 있다고 생각하고 설계하는 일은 거의 없다.
	- 이러한 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방하다.
    
2. 클래스 기반으로 작성된 프레임워크가 제공하는 객체들이다.
	- 특정 구현 클래스보다는 기반 클래스를 사용해 참조하는 게 좋다.(OutputStream 등 java.io 패키지의 여러 클래스가 이 부류)
    
ex) PriorityQueue 클래스는 Queue 인터페이스에는 없는 comparator 메서드를 제공하는데, 클래스 타입을 직접 사용하는 경우는 이런 추가 메서드를 꼭 사용해야 하는 경우로 최소화해야 하며, 절대 남발하지 말아야 한다.

```java
PriorityQueue<Integer> pq = new PriorityQueue<>(); // 이렇게 사용한다(Queue에는 comparator가 없기때문!)
Queue<Integer> q = new PriorityQueue<>(); // 이렇게 사용하지 않음
```

실전에서는 주어진 객체를 표현할 적절한 인터페이스가 있는지 찾아서 그 인터페이스로 참조하면 더 유연하고 세련된 프로그램을 만들 수 있다.

### 정리
**적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자!**
