## Item 86 : Serializable 을 구현할지는 신중히 결정하라
### Conclusion
버전간 호환성 문제나 보안 취약점을 가질수 있기 때문에 굳이 필요하지 않다면 Serializable 을 구현하지 마라.(직렬화를 지원하지 마라)

### In case
직렬화를 사용하기 위해서는 클래스가 Serializable 만 구현하면 끝이지만 잘 사용하기란 쉽지 않다.

##### 유지보수 측면에서의 문제
커스텀 직렬화를 구현하지 않고, 자바의 기본 방식을 사용하면 직렬화 형태는 최소 적용 당시 클래스의 내부 구현 방식에 영원히 묶인다.  
좀 더 이해하기 쉽게 설명하자면  
자바 기본 직렬화는 클래스 내부의 메소드와 transient 키워드를 사용하지 않은 멤버 변수는 전부 직렬화 대상이 되기 때문에,  
인스턴스를 직렬화 한 후 해당 바이트 스트림을 계속 사용한다 가정했을때, 문제 없이 이를 지원 하기 위해서는 내부 구현을 바꿀수 없게 되기 때문에 영원히 묶인다고 표현 하였다.  
내부 구현을 손보면서도 예전 직렬화 된 바이트 스트림을 그대로 사용할수 있는 방법도 있긴하지만, 필요 없는 혹(역직렬화 호환성을 위해 남겨 두어야하는 필드들)이 생길수도 있으니 주의 해야한다.  

Serializable 을 구현한 클래스는 모두 serialVersionUID 라는 식별 번호를 부여받게 되는데, 이 식별 번호로 역직렬화가 가능한지 판별한다.   
자동으로 생성된 식별번호는 내부적으로 런타임에 생성하는데, 클래스 이름, 구현한 인터페이스, 컴파일러가 자동 생성한 필드를 포함한 대부분의 필드까지 포함해서 생성하게 되므로,  
자동 생성으로 둔 상태에서 클래스 버전이 달라지게 된다면 역직렬화는 실패하게 된다.  
때문에 버전이 바뀔수 있고, 그때도 역 직렬화가 잘 되어야 한다면 이 식별 번호를 수동으로 부여하라.  

클래스의 새 버전을 릴리즈할때 테스트할 것이 늘어난다.  
직렬화-역직렬화도 공개 api 인 셈이므로 이를 테스트해야 한다는 뜻이다.  
다만 버전이 늘어날수록 하위 호환성을 다 챙길수 있는지 테스트 해야하므로 버전이 늘어날수록 테스트의 양이 기하급수적으로 늘어날수 있다.


이런 문제들로 새 버전 릴리즈의 부담이 생긴다.

##### 사이드 이펙트 측면에서의 문제 
역 직렬화는 숨은 생성자와 마찬가지이다.  
자바가 제공하는 생성기법을 우회하는것이나 마찬가지이기 때문에 역 직렬화시 '생성자에서 구축한 불변식'을 보장해야한다고 한다.  
생성자에 의해서 설정된 불변성은 역 직렬화시 달라질수 있다고 경고하는데,   
공격자가 임의로 만들어낸, 혹은 버전이 바뀌며 바뀐 불변성에 의해 버그가 발생할수 있다는 이야기이다.  
-- readObjectNoData()

##### 상속 측면에서의 문제 
상속용으로 만들어진 클래스는 되도록이면 Serializable을 구현해서는 안되며, 인터페이스도 마찬가지이다.  
상속한 클래스도 마찬가지로 위의 문제점을 겪을수 있고, 사용자는 그것을 원하지 않을수도 있기 때문이다.

만약 상속용으로 직렬화 가능한 클래스를 만들어야한다면...


finalizer공격을 대비해 finalize메서드를 final로 재정의하여 방어하라.

<details>
<summary>상속이 될수도 있고, 기본값으로 초기화 되면 안되는 필드를 가진 클래스라면 readObjectNoData() 메서드를 추가하라. </summary>

해당 메서드는 ObjectReadStream에서 read시에 클래스에 멤버는 존재하지만 바이트 스트림에 해당 데이터가 존재하지 않을때 실행된다.  
이 메서드로 클래스의 불변식을 지켜줄수도 있으나, 서브 클래스는 직렬화 할 필요가 없다면 책에서 처럼 예외를 throw 시켜주는 방법으로도 사용이 가능하다.  
</details>

상속용 클래스이지만 자신은 직렬화를 하지 못하게 할때는 생성자를 제공하라.  
그렇지 않으면 서브 클래스에서 직렬화 프록시 패턴을 사용해야한다.


객체를 전송해야하거나, 직렬화를 이용한 framework를 사용시 선택의 여지가 없지만 그 이외에는 Serializable의 구현은 다시 생각해봐라.  
기본 직렬화 방식을 사용한다면 저런 문제들이 따를것이고, 커스텀 직렬화 방식을 사용해야한다면 고려해야할점이 많을것이다.




## in my opinion
"Serializable을 한번 구현해 릴리즈 한 이후에는 수정하기 어렵다" 라는 내용은  
item 15에서 이야기한 접근성을 최대한 줄여 유지보수성을 늘리라는 말에 포함되는 이야기이다.  
Serializable 을 구현하였기 때문에 수정하기 어려운것이 아니라, 릴리즈 이후엔 클라이언트에게 영향을 줄수 있기 때문에 수정하기 어려운 것이다.  

"기본 직렬화 형태에서는 클래스의 private 필드가 api로 공개되는 꼴이 된다" 라고 하였는데, 이해가 되지 않는다.  
public 으로 공개한 api는 마음대로 내부 구현을 수정하기 어렵다는 점에서 마찬가지로 역직렬화를 생각했을때 내부 구현을 맘대로 바꾸기 어렵기 때문에 이렇게 표현한것인지?  
아니면 private으로 내부 필드를 숨기려고 하였고, 내부 필드에 대한 접근 권한도 메서드로 제공하지 않아도 직렬화 되며 나온 결과물이 내부 필드를 공개하고 있기 때문에 그렇다는 것인지?  


inner class 는 직렬화를 구현하지 말아야한다.(nested class가 아니라)  
inner class 는 바로 바깥의 인스턴스를 참조할수 있고, 그 참조를 위한 지역변수를 위해 컴파일러가 생성한 필드가 있다.
-- 테스트 해보았는데 잘 되는게, 테스트가 잘못된 것인지.. vm마다 다른것인지..



