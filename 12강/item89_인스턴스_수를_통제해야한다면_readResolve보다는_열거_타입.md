## Item 89 : 인스턴스 수를 통제한다면 readResolve 보다는 열거 타입을 사용하라
### Conclusion
싱글턴 인스턴스를 만들때는 enum 사용을 고려하라

### In case
싱글턴 인스턴스를 보장하기 위해서 readResolve 메서드를 사용할수 있다.  
readResolve 는 역 직렬화 진행중 ObjectInputStream에 의해서 호출되는데,   
readResolve 메서드 내에서 직렬화된 객체를 검사하고, 필요한 변환따위를 할수 있다.

책에서 readResolve 를 이용하여 싱글턴임을 보장하기 위해서 사용한 방법은   
싱글턴 인스턴스 내부에 가지고 있는 인스턴스를 리턴하여  
역직렬화 되어 새로 만들어진 객체를 무시하는 방법이다.  
(참조 되지 못한 객체가 되므로 생성은 되지만 곧 gc되어버림)

![](https://raw.githubusercontent.com/mycode01/linkimages/master/effective_java/efj_item89_01.png)
readResolve가 실행될 시점에는 이미 객체가 생성된 이후이므로 완벽하게 싱글턴임을 보장할순 없지만  
리턴 된 이후에는 참조 변수가 없게 되므로 결과적으로 싱글턴을 보장하는 방법이다.

하지만 위에서 설명했듯 readResolve가 실행될 시점에는 이미 객체가 생성되어 private 멤버 역시 값이 할당된 상태인데,  
이 private 멤버도 직렬화의 대상이 되므로 마찬가지로 readResolve가 실행되어야한다.     
이를 이용하여 역직렬화 완료된 객체의 참조를 훔쳐내 싱글턴을 깨는 방법이 있다.  

위에서 설명하듯 readResolve에서 리턴 된 이후에는 생성된 싱글턴(여러개 존재함)이 참조를 잃어버리므로 gc되어 결과적 싱글턴을 보장하는데,  
readResolve에서 리턴되기 전에 참조를 빼돌리는 방법이다.  
참조를 빼돌릴 도둑 객체를 만들고,  
직렬화 된 바이트를 수정하여 private 의 멤버를 도둑 객체로 참조를 바꾸어   
도둑객체의 readResolve가 실행될때 싱글턴의 객체 참조를 가져와 보관하여 gc되지 못하게 막아 싱글턴을 깨는 방법이다.  

이처럼 역 직렬화 순간에 새로 만들어진 객체에 접근하지 못하게 하는 방법은 깨지기 쉬우므로  
이런 방법보다는 그냥 enum 타입을 사용하여 싱글턴을 보장하라고 추천함.  


## in my opinion
enum으로 싱글턴을 보장한다 해도 reflection을 이용한다면 싱글턴을 깰수 있다고 했는데..  
일단 테스트해본 바로는 단순한 reflection으로는 enum 객체를 생성할수 없었고(jdk17)  
'네이티브 코드를 수행할수 있는' 이라는 단서가 붙은걸로 봐서는 뭔가 더 어려운 방법을 사용해야 가능한듯 하다.  


